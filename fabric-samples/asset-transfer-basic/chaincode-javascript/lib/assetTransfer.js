/*
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';

// Deterministic JSON.stringify()
const stringify = require('json-stringify-deterministic');
const sortKeysRecursive = require('sort-keys-recursive');
const { Contract } = require('fabric-contract-api');

class AssetTransfer extends Contract {

    //Inicializa o ledger com um conjunto de ativos pr√©-definidos.
    async InitLedger(ctx) {
        const assets = [
            {
                id: 'item1',
                evidenceType: 'üß¨ Biol√≥gica',
                description: 'Amostra de sangue coletada na cena do crime',
                collectionLocation: 'Sala de estar - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T11:30:00-03:00',
                collectorAgent: 'Perito Leandro (ID 001)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üßä Geladeira Forense',
                evidenceStatus: 'Em an√°lise',
                sealNumber: 'SEAL001',
                sealType: 'Pl√°stico',
                sealState: '√çntegro',
                additionalNotes: 'Amostra coletada com luvas est√©reis',
                custodian: 'Dr.¬™ Souza',
                evidenceHashes: [],
            },
            {
                id: 'item2',
                evidenceType: 'üñêÔ∏è Impress√£o digital',
                description: 'Impress√£o digital encontrada na janela',
                collectionLocation: 'Janela lateral - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T12:45:00-03:00',
                collectorAgent: 'Oficial Silva (ID 006)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üè¢ Dep√≥sito Central',
                evidenceStatus: 'Arquivada',
                sealNumber: 'SEAL002',
                sealType: 'Adesivo',
                sealState: '√çntegro',
                additionalNotes: 'Coletada com fita adesiva especial',
                custodian: 'Oficial Silva',
                evidenceHashes: [],
            },
            {
                id: 'item3',
                evidenceType: 'üß¨ DNA',
                description: 'Amostra de DNA extra√≠da de cabelo',
                collectionLocation: 'Quarto principal - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T13:20:00-03:00',
                collectorAgent: 'Perito Gerson (ID 002)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üß™ Laborat√≥rio de Biologia',
                evidenceStatus: 'Em an√°lise',
                sealNumber: 'SEAL003',
                sealType: 'Numerado',
                sealState: '√çntegro',
                additionalNotes: 'Amostra enviada para an√°lise gen√©tica',
                custodian: 'T√©cnico Lima',
                evidenceHashes: [],
            },
            {
                id: 'item4',
                evidenceType: 'üî´ Bal√≠stica',
                description: 'Arma de fogo apreendida no local',
                collectionLocation: 'Cozinha - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T14:10:00-03:00',
                collectorAgent: 'Agente Primm (ID 004)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üîí Cofre',
                evidenceStatus: 'Arquivada',
                sealNumber: 'SEAL004',
                sealType: 'Met√°lico',
                sealState: '√çntegro',
                additionalNotes: 'Arma descarregada e lacrada',
                custodian: 'Detetive Souza',
                evidenceHashes: [],
            },
            {
                id: 'item5',
                evidenceType: 'üì∑ Imagem/V√≠deo',
                description: 'V√≠deo de vigil√¢ncia da cena do crime',
                collectionLocation: 'Sistema de CFTV - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T15:00:00-03:00',
                collectorAgent: 'Agente Luiz (ID 005)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üíª Laborat√≥rio de Digital',
                evidenceStatus: 'Em an√°lise',
                sealNumber: 'SEAL005',
                sealType: 'RFID',
                sealState: '√çntegro',
                additionalNotes: 'Backup realizado em m√∫ltiplos dispositivos',
                custodian: 'Agente Dumes',
                evidenceHashes: [],
            },
            {
                id: 'item6',
                evidenceType: 'üìÑ Documental',
                description: 'Documentos encontrados na cena',
                collectionLocation: 'Escrit√≥rio - Rua das Flores, 123',
                collectionDatetime: '2024-01-15T16:30:00-03:00',
                collectorAgent: 'Perito Maur√≠cio (ID 003)',
                evidenceCondition: '√çntegra',
                storageLocation: 'üì¶ Arquivo Morto',
                evidenceStatus: 'Arquivada',
                sealNumber: 'SEAL006',
                sealType: 'Barra de seguran√ßa',
                sealState: '√çntegro',
                additionalNotes: 'Documentos digitalizados e originais preservados',
                custodian: 'Analista Figueira',
                evidenceHashes: [],
            },
        ];

        for (const asset of assets) {
            asset.docType = 'forensicItem';
            await ctx.stub.putState(asset.id, Buffer.from(stringify(sortKeysRecursive(asset))));
            await this.createTransferRecord(ctx, asset.id, asset.custodian, 'InitLedger');
        }
    }

    // Adiciona um novo ativo ao ledger com o novo modelo de evid√™ncia.
    async AddItem(ctx, id, evidenceType, description, collectionLocation, collectionDatetime, collectorAgent, evidenceCondition, storageLocation, evidenceStatus, sealNumber, sealType, sealState, additionalNotes) {
        const exists = await this.itemExists(ctx, id);
        if (exists) {
            throw new Error(`Item ${id} already exists`);
        }

        const asset = {
            id,
            evidenceType,
            description,
            collectionLocation,
            collectionDatetime,
            collectorAgent,
            evidenceCondition,
            storageLocation,
            evidenceStatus,
            sealNumber,
            sealType,
            sealState,
            additionalNotes,
            custodian: collectorAgent, // O custodiante inicial √© o agente coletor
            evidenceHashes: [],
        };

        await ctx.stub.putState(id, Buffer.from(stringify(sortKeysRecursive(asset))));
        await this.createTransferRecord(ctx, id, collectorAgent, 'AddItem');
        return JSON.stringify(asset);
    }

    // Transfere a cust√≥dia de um ativo de um custodiante para outro.
    async TransferCustody(ctx, id, newCustodian) {
        const itemString = await this.ReadIndividual(ctx, id);
        const item = JSON.parse(itemString);
        const oldCustodian = item.custodian;
        item.custodian = newCustodian;

        await ctx.stub.putState(id, Buffer.from(stringify(sortKeysRecursive(item))));
        await this.createTransferRecord(ctx, id, newCustodian, 'TransferCustody');
        return oldCustodian;
    }

    // Recupera os detalhes de um ativo espec√≠fico.
    async ReadIndividual(ctx, id) {
        const itemJSON = await ctx.stub.getState(id);
        if (!itemJSON || itemJSON.length === 0) {
            throw new Error(`Item ${id} does not exist`);
        }
        return itemJSON.toString();
    }

    // Recupera uma lista de todos os ativos no ledger.
    async ReadAll(ctx) {
        const allResults = [];
        const iterator = await ctx.stub.getStateByRange('', '');
        let result = await iterator.next();
        while (!result.done) {
            const strValue = Buffer.from(result.value.value.toString()).toString('utf8');
            let record;
            try {
                record = JSON.parse(strValue);
            } catch (err) {
                console.log(err);
                record = strValue;
            }
            if (!record.txId) {  // Filter only asset records (without TxID)
                allResults.push(record);
            }
            result = await iterator.next();
        }
        return JSON.stringify(allResults);
    }
    
    // Recupera uma lista de todos os registros de transfer√™ncia (ou seja, registros de transfer√™ncia de cust√≥dia).
    async ReadCustodyRecords(ctx) {
        const allResults = [];
        const iterator = await ctx.stub.getStateByRange('', '');
        let result = await iterator.next();
        while (!result.done) {
            const strValue = Buffer.from(result.value.value.toString()).toString('utf8');
            let record;
            try {
                record = JSON.parse(strValue);
            } catch (err) {
                console.log(err);
                record = strValue;
            }
            if (record.txId) {  // Filter only transfer records (with TxID)
                allResults.push(record);
            }
            result = await iterator.next();
        }
        return JSON.stringify(allResults);
    }

    // Cria um novo registro de transfer√™ncia quando a cust√≥dia de um ativo √© transferida.
    async createTransferRecord(ctx, itemId, newCustodian, transactionType) {
        // Converte o timestamp para UTC-3 (hor√°rio de Bras√≠lia)
        const utcTimestamp = (await ctx.stub.getTxTimestamp()).seconds.low * 1000;
        const brasiliaDate = new Date(utcTimestamp - (3 * 60 * 60 * 1000)); // Subtrai 3 horas para UTC-3
        const timestamp = brasiliaDate.toISOString();
        
        const transferRecord = {
            itemId,
            custodian: newCustodian,
            transactionType,
            timestamp,
            txId: ctx.stub.getTxID()
        };
        const transferRecordId =`transfer_${itemId}_${ctx.stub.getTxID()}`;
        await ctx.stub.putState(transferRecordId, Buffer.from(stringify(sortKeysRecursive(transferRecord))));
    }

    // Verifica se um ativo com um ID espec√≠fico existe no ledger.
    async itemExists(ctx, id) {
        const itemJSON = await ctx.stub.getState(id);
        return itemJSON && itemJSON.length > 0;
    }

    // Adiciona um novo hash de evid√™ncia ao asset
    async AddEvidenceHash(ctx, id, hash) {
        const itemString = await this.ReadIndividual(ctx, id);
        const item = JSON.parse(itemString);
        if (!item.evidenceHashes) {
            item.evidenceHashes = [];
        }
        item.evidenceHashes.push(hash);
        await ctx.stub.putState(id, Buffer.from(stringify(sortKeysRecursive(item))));
        return JSON.stringify(item);
    }
}

module.exports = AssetTransfer;
